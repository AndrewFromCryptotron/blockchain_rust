use crate::node::*;
use sn_merkle::merkle::MerkleTree;
use std::time::{Duration};
use tonic::codegen::Arc;
use tokio::sync::Mutex;
use log::{info, error};
use std::collections::HashMap;
use sha3::{Sha3_512, Digest};
use sn_cryptography::cryptography::Keypair;
use sn_proto::messages::*;
use ed25519_dalek::{PublicKey, Verifier, Signature};
use anyhow::Result;
use sn_chain::chain::Chain;
use std::time::SystemTime;
use std::time::UNIX_EPOCH;
use sn_block::block::*;

#[derive(Clone, Debug)]
pub struct PoHEntry {
    pub relative_timestamp: i64,
    pub transaction_hash: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct Validator {
    pub validator_id: i32,
    pub poh_sequence: Arc<Mutex<Vec<PoHEntry>>>,
    pub node_service: Arc<NodeService>,
    pub tower: Arc<Mutex<Tower>>,
}

impl Validator {
    pub async fn start_validator_tick(&self) {
        let node_clone = self.clone();
        let mut interval = tokio::time::interval(Duration::from_secs(1));
        loop {
            interval.tick().await;
            let num_transactions = node_clone.node_service.mempool.len().await;
            if num_transactions >= 100 {
                node_clone.initialize_validation().await;
            }
        }
    }

    pub async fn initialize_validation(&self) {
        let public_key_hex = hex::encode(&self.node_service.server_config.cfg_keypair.public.as_bytes());
        let txx = self.node_service.mempool.clear().await;
        info!("\n{}: new block created by {} with {} transactions", self.node_service.server_config.cfg_addr, public_key_hex, txx.len());
    }

    pub async fn start_poh_tick(&self) {
        let node_clone = self.clone();
        let mut interval = tokio::time::interval(Duration::from_secs(1));
        loop {
            interval.tick().await;
            node_clone.generate_poh_entry(None).await;
        }
    }

    pub async fn generate_poh_entry(&self, transaction_hash: Option<Vec<u8>>) {
        let mut poh_sequence = self.poh_sequence.lock().await;
        let relative_timestamp = match poh_sequence.last() {
            Some(last_entry) => last_entry.relative_timestamp + 1,
            None => 0,
        };
        let entry_hash = match transaction_hash {
            Some(hash) => {
                let prev_hash = poh_sequence.last().unwrap().transaction_hash.clone();
                let mut combined_hash = prev_hash;
                combined_hash.extend(hash);
                hash_poh_entering_transaction(&combined_hash).await
            }
            None => Vec::new(),
        };
        let entry = PoHEntry {
            relative_timestamp,
            transaction_hash: entry_hash,
        };
        poh_sequence.push(entry);
    }

    pub async fn verify_poh_entry(&self, entry: &PoHEntry) -> bool {
        let poh_sequence = self.poh_sequence.lock().await;
        if let Some(prev_entry) = poh_sequence.get(entry.relative_timestamp as usize - 1) {
            if entry.relative_timestamp != prev_entry.relative_timestamp + 1 {
                return false;
            }
            let mut combined_hash = prev_entry.transaction_hash.clone();
            combined_hash.extend(&entry.transaction_hash);
            let calculated_hash = hash_poh_entering_transaction(&combined_hash).await;
            calculated_hash == entry.transaction_hash
        } else {
            false
        }
    }

    pub async fn finalize_block(&self) {
        let agreements = self.agreements.lock().await;
        if let Some((winning_hash, _)) = agreements.iter().max_by_key(|(_, &count)| count) {
            let block = self.blocks.lock().await.get(winning_hash).cloned();
            if let Some(block) = block {
                self.commit_block(block).await;
                info!("Block {} has been finalized and committed.", block.msg_height.unwrap());
            }
        }
    }

    pub async fn commit_block(&self, block_height: u64) {
        // Add the block to the chain, update the state, and perform any necessary actions
    }

    pub async fn propose_unsigned_block(&self, block: &Block) {
        if let Some(header) = &block.msg_header {
            let msg_validator_id = self.validator_id as u64;
            let msg_block_height = header.msg_height as u64;
            let keypair = &self.node_service.server_config.cfg_keypair;
            let msg_fingerprint = sign_vote(msg_validator_id, msg_block_height, keypair);
            let vote = Vote {
                msg_validator_id,
                msg_block_height,
                msg_fingerprint,
            };
            let mut tower = self.tower.lock().await;
            self.process_vote(&vote, &mut *tower).await;
            self.broadcast_vote(&vote).await;
        } else {
            error!("The block is missing a header");
        }
    }

    pub async fn broadcast_block_hash(&self, block_hash: Vec<u8>) {
        let peers = self.node_service.peer_lock.read().await;
        for (_, (peer, _, is_validator)) in peers.iter() {
            if *is_validator {
                let mut peer = peer.lock().await;
                let _ = peer.handle_block_hash(block_hash.clone()).await;
            }
        }
    }

    pub async fn compare_block_hashes(&self, received_hash: Vec<u8>, local_hash: Vec<u8>) -> bool {
        received_hash == local_hash
    }
    
    pub fn verify_vote(validator_id: u64, block_height: u64, fingerprint: [u8; 64], public_key: &[u8]) -> bool {
        let mut hasher = Sha3_512::new();
        hasher.update(validator_id.to_le_bytes());
        hasher.update(block_height.to_le_bytes());
        let message_hash = hasher.finalize();
        let signature = Signature::from_bytes(&fingerprint).unwrap();
        let public_key = PublicKey::from_bytes(public_key).unwrap();
        public_key.verify(&message_hash, &signature).is_ok()
    }

    pub async fn process_vote(&self, block_hash: Vec<u8>) {
        let local_block = self.create_block(chain).await.unwrap();
        let local_block_hash = hash_block(&local_block).await;
        let agreement = self.compare_block_hashes(block_hash.clone(), local_block_hash).await;

        let mut agreements = self.agreements.lock().await;
        let count = agreements.entry(block_hash).or_insert(0);
        *count += if agreement { 1 } else { 0 };

        self.broadcast_block_hash(block_hash).await;
    }
    
    pub async fn create_block(&self, chain: &Chain) -> Result<Block> {
        let keypair = &self.node_service.server_config.cfg_keypair;
        let public_key = keypair.public.to_bytes().to_vec();
        let msg_height = (Chain::chain_height(chain) + 1) as i32;
        let transactions = self.node_service.mempool.clear().await;
        let merkle_tree = MerkleTree::new(&transactions).unwrap();
        let merkle_root = merkle_tree.root.to_vec();
        let header = Header {
            msg_version: 1,
            msg_height,
            msg_previous_hash: vec![],
            msg_root_hash: merkle_root,
            msg_timestamp: 0, // Remove timestamp
        };
        let block = Block {
            msg_header: Some(header),
            msg_transactions: transactions,
            msg_public_key: public_key,
            msg_signature: vec![], // Remove signature
        };
        Ok(block)
    }
}

pub fn sign_vote(validator_id: u64, block_height: u64, keypair: &Keypair) -> Vec<u8> {
    let mut hasher = Sha3_512::new();
    hasher.update(validator_id.to_le_bytes());
    hasher.update(block_height.to_le_bytes());
    let message_hash = hasher.finalize();
    keypair.sign(&message_hash).to_bytes().to_vec()
}

pub async fn hash_poh_entering_transaction(extended_hash: &Vec<u8>) -> Vec<u8> {
    let mut hasher = Sha3_512::new();
    hasher.update(&extended_hash);
    hasher.finalize().to_vec()
}

#[derive(Clone, Debug)]
pub struct Tower {
    pub locks: HashMap<u64, u64>, // block ID => lock level
}

impl Tower {
    pub fn update_lock(&mut self, vote: &Vote) {
        let validator_id = vote.msg_validator_id;
        let block_height = vote.msg_block_height;
        if let Some(current_lock) = self.locks.get_mut(&validator_id) {
            if *current_lock < block_height {
                *current_lock = block_height;
            }
        } else {
            self.locks.insert(validator_id, block_height);
        }
    }

    pub fn get_finalized_blocks(&self) -> Vec<u64> {
        let quorum = self.get_quorum();
        self.locks.iter()
            .filter_map(|(&validator_id, &lock_level)| {
                let lock_count = self.locks.values()
                    .filter(|&level| *level == lock_level)
                    .count();
                if lock_count >= quorum {
                    Some(validator_id)
                } else {
                    None
                }
            })
            .collect()
    }

    pub fn get_quorum(&self) -> usize {
        (self.locks.len() / 2) + 1
    }
}


I want to change the consensus mechanism:
1. All validators create their versions of created block without timestamp and signature
2. hash this unsigned and untimestamed block
3. broadcast this hash to the other validators
4. all validators are comparing recieved hash to their version of hash, if they are equal, they return something like "agree", if not - "disagree" (it can be simple bool)
5. Version of the hash that got  most "agree"'s will be chosen to be the block to be added to the chain


use crate::node::*;
use sn_merkle::merkle::MerkleTree;
use sn_block::block::*;
use std::time::{Duration};
use tonic::codegen::Arc;
use tokio::sync::Mutex;
use log::{info};
use std::collections::HashMap;
use sha3::{Sha3_512, Digest};
use sn_cryptography::cryptography::Keypair;
use sn_proto::messages::*;
use anyhow::Result;
use sn_chain::chain::Chain;

#[derive(Clone, Debug)]
pub struct PoHEntry {
    pub relative_timestamp: i64,
    pub transaction_hash: Vec<u8>,
}

#[derive(Clone, Debug)]
pub struct Validator {
    pub validator_id: i32,
    pub poh_sequence: Arc<Mutex<Vec<PoHEntry>>>,
    pub node_service: Arc<NodeService>,
    pub tower: Arc<Mutex<Tower>>,
}

impl Validator {
    pub async fn start_validator_tick(&self) {
        // LOGIC
    }

    pub async fn initialize_validation(&self, chain: &Chain) {
        // LOGIC
    }

    pub async fn broadcast_block_hash(&self, block_hash: &Vec<u8>) {
        // LOGIC
    }

    pub async fn on_vote_received(&self, vote: bool, block_hash: Vec<u8>) {
        // LOGIC
    }

    pub async fn broadcast_vote(&self, vote: bool, block_hash: Vec<u8>) {
        // LOGIC
    }

    pub async fn add_block_to_chain(&self, block_hash: Vec<u8>) {
        // LOGIC
    }

    pub async fn start_poh_tick(&self) {
        let node_clone = self.clone();
        let mut interval = tokio::time::interval(Duration::from_secs(1));
        loop {
            interval.tick().await;
            node_clone.generate_poh_entry(None).await;
        }
    }

    pub async fn generate_poh_entry(&self, transaction_hash: Option<Vec<u8>>) {
        let mut poh_sequence = self.poh_sequence.lock().await;
        let relative_timestamp = match poh_sequence.last() {
            Some(last_entry) => last_entry.relative_timestamp + 1,
            None => 0,
        };
        let entry_hash = match transaction_hash {
            Some(hash) => {
                let prev_hash = poh_sequence.last().unwrap().transaction_hash.clone();
                let mut combined_hash = prev_hash;
                combined_hash.extend(hash);
                hash_poh_entering_transaction(&combined_hash).await
            }
            None => Vec::new(),
        };
        let entry = PoHEntry {
            relative_timestamp,
            transaction_hash: entry_hash,
        };
        poh_sequence.push(entry);
    }

    pub async fn verify_poh_entry(&self, entry: &PoHEntry) -> bool {
        let poh_sequence = self.poh_sequence.lock().await;
        if let Some(prev_entry) = poh_sequence.get(entry.relative_timestamp as usize - 1) {
            if entry.relative_timestamp != prev_entry.relative_timestamp + 1 {
                return false;
            }
            let mut combined_hash = prev_entry.transaction_hash.clone();
            combined_hash.extend(&entry.transaction_hash);
            let calculated_hash = hash_poh_entering_transaction(&combined_hash).await;
            calculated_hash == entry.transaction_hash
        } else {
            false
        }
    }
    
    pub async fn create_block_hash(&self, chain: &Chain) -> Result<Vec<u8>> {
        let keypair = &self.node_service.server_config.cfg_keypair;
        let public_key = keypair.public.to_bytes().to_vec();
        let msg_height = (Chain::chain_height(chain) + 1) as i32;
        let transactions = self.node_service.mempool.clear().await;
        let merkle_tree = MerkleTree::new(&transactions).unwrap();
        let merkle_root = merkle_tree.root.to_vec();
        let header = Header {
            msg_version: 1,
            msg_height,
            msg_previous_hash: vec![],
            msg_root_hash: merkle_root,
            msg_timestamp: 0, // Remove timestamp
        };
        let block = Block {
            msg_header: Some(header.clone()),
            msg_transactions: transactions,
            msg_public_key: public_key,
            msg_signature: vec![], // Remove signature
        };
        let hash = hash_header(&header).await.unwrap().to_vec();
        Ok(hash)
    }
}

pub async fn hash_poh_entering_transaction(extended_hash: &Vec<u8>) -> Vec<u8> {
    let mut hasher = Sha3_512::new();
    hasher.update(&extended_hash);
    hasher.finalize().to_vec()
}

#[derive(Clone, Debug)]
pub struct Tower {
    pub block_votes: HashMap<Vec<u8>, u32>, // block hash => vote count
}

impl Tower {
    pub async fn update_block_votes(self, block_hash: Vec<u8>) {
        let mut block_votes = self.block_votes;
        let count = block_votes.entry(block_hash).or_insert(0);
        *count += 1;
    }

    // Add a method to get the vote count for a block hash
    pub async fn get_vote_count(&self, block_hash: &Vec<u8>) {
        // LOGIC
    }

    // ...

    pub fn get_quorum(&self) {
        // LOGIC
    }
}

