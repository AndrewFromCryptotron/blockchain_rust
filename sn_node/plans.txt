Parallelize block creation: In the validator_tick method, you could also parallelize the process of creating a new block 
from the mempool transactions. For instance, you can divide the transactions into smaller groups and assign them to 
different tasks for processing. Once all tasks are completed, you can merge the results to create the final block.

_______________________________________________________________________________________________________________________________

Distributed Hash Table (DHT): You can use a DHT like Kademlia to store information about active nodes in the network. 
In Kademlia, nodes are assigned a unique identifier based on their IP addresses. When a node wants to discover other 
nodes, it sends a lookup request to the closest nodes it knows about, which in turn forward the request to their closest 
nodes. This process continues until the target node is found. By implementing a DHT, your nodes can efficiently find 
and connect to other nodes in the network without manual input.

Node bootstrap: When a new node joins the network, it needs a way to discover initial peers. You can set up a few well-known, 
stable bootstrap nodes that new nodes can connect to when they first join the network. These bootstrap nodes can help new 
nodes find other peers and populate their initial routing tables.

Periodic peer discovery: Nodes should periodically refresh their knowledge of the network by sending out peer discovery 
requests. This ensures that they stay up-to-date with the active nodes in the network and can adapt to changes in the network 
topology.

NAT traversal techniques: If your nodes are behind NATs or firewalls, you might need to implement NAT traversal techniques 
like STUN, TURN, or ICE to help nodes establish direct connections with each other.

Peer exchange (PEX): Once nodes are connected, they can exchange information about other known nodes. This helps them 
maintain an updated list of active peers and discover new nodes as they join the network.

{{{{{{
    Choose a DHT library, like rust-libp2p for Rust, that supports Kademlia, and integrate it into your project.

    Set up and maintain a few well-known bootstrap nodes that new nodes can connect to when they first join the network.

    Modify your node's logic to perform periodic peer discovery using the DHT and update its internal list of active nodes.

    Implement NAT traversal techniques, if necessary, to help nodes establish direct connections with each other.

    Modify your gRPC communication protocol to include peer exchange messages so that nodes can share information about other 
    known nodes with each other.
}}}}}}

I want to break this function to two functions:
first fill create common nodeService and if node_service.server_config.cfg_is_validator is set to true initiate validator and place it to the vlidator field of the node service
#[derive(Clone)]
pub struct NodeService {
    pub server_config: ServerConfig,
    pub peer_lock: Arc<RwLock<HashMap<String, (Arc<Mutex<NodeClient<Channel>>>, Version, bool)>>>,
    pub validator: Option<Arc<ValidatorService>>,
}
impl NodeService {
    pub async fn new(cfg: ServerConfig) -> Self {
        info!("NodeService {} created", cfg.cfg_addr);
        let peer_lock = Arc::new(RwLock::new(HashMap::new()));
        let block_storer: Box<dyn BlockStorer> = Box::new(MemoryBlockStore::new());
        let tx_storer: Box<dyn TXStorer> = Box::new(MemoryTXStore::new());
        let chain = match Chain::new_chain(block_storer, tx_storer).await {
            Ok(chain) => Arc::new(RwLock::new(chain)),
            Err(e) => panic!("Failed to create chain: {:?}", e),
        };
        let node_service = NodeService {
            server_config: cfg.clone(),
            peer_lock: Arc::clone(&peer_lock),
            validator: None,
        };
        let validator = if cfg.cfg_is_validator {
            let validator = ValidatorService {
                validator_id: 0,
                node_service: Arc::new(node_service.clone()),
                mempool: Arc::new(Mempool::new()),
                round_transactions: Arc::new(Mutex::new(Vec::new())),
                created_block: Arc::new(Mutex::new(None)),
                agreement_count: Arc::new(Mutex::new(0)),
                vote_count: Arc::new(Mutex::new(HashMap::new())),
                received_responses_count: Arc::new(Mutex::new(0)),
                chain: Arc::clone(&chain),
                trigger_sender: Arc::new(Mutex::new(None)),
            };
            Some(Arc::new(validator))
        } else {
            None
        };
        NodeService {
            server_config: cfg,
            peer_lock,
            validator,
        }
    }    
#[derive(Clone)]
pub struct ValidatorService {
    pub validator_id: i32,
    pub node_service: Arc<NodeService>,
    pub mempool: Arc<Mempool>,
    pub round_transactions: Arc<Mutex<Vec<Transaction>>>,
    pub created_block: Arc<Mutex<Option<(Block, Vec<u8>)>>>,
    pub agreement_count: Arc<Mutex<usize>>,
    pub vote_count: Arc<Mutex<HashMap<u64, usize>>>,
    pub received_responses_count: Arc<Mutex<usize>>,
    pub chain: Arc<RwLock<Chain>>,
    pub trigger_sender: Arc<Mutex<Option<oneshot::Sender<()>>>>,
}