Distributed Hash Table (DHT): You can use a DHT like Kademlia to store information about active nodes in the network. 
In Kademlia, nodes are assigned a unique identifier based on their IP addresses. When a node wants to discover other 
nodes, it sends a lookup request to the closest nodes it knows about, which in turn forward the request to their closest 
nodes. This process continues until the target node is found. By implementing a DHT, your nodes can efficiently find 
and connect to other nodes in the network without manual input.

Node bootstrap: When a new node joins the network, it needs a way to discover initial peers. You can set up a few well-known, 
stable bootstrap nodes that new nodes can connect to when they first join the network. These bootstrap nodes can help new 
nodes find other peers and populate their initial routing tables.

Periodic peer discovery: Nodes should periodically refresh their knowledge of the network by sending out peer discovery 
requests. This ensures that they stay up-to-date with the active nodes in the network and can adapt to changes in the network 
topology.

NAT traversal techniques: If your nodes are behind NATs or firewalls, you might need to implement NAT traversal techniques 
like STUN, TURN, or ICE to help nodes establish direct connections with each other.

Peer exchange (PEX): Once nodes are connected, they can exchange information about other known nodes. This helps them 
maintain an updated list of active peers and discover new nodes as they join the network.

{{{{{{
    Choose a DHT library, like rust-libp2p for Rust, that supports Kademlia, and integrate it into your project.

    Set up and maintain a few well-known bootstrap nodes that new nodes can connect to when they first join the network.

    Modify your node's logic to perform periodic peer discovery using the DHT and update its internal list of active nodes.

    Implement NAT traversal techniques, if necessary, to help nodes establish direct connections with each other.

    Modify your gRPC communication protocol to include peer exchange messages so that nodes can share information about other 
    known nodes with each other.
}}}}}}

error[E0277]: `?` couldn't convert the error to `vec_errors::errors::ChainError`
  --> vec_chain\src\chain.rs:90:43
   |
90 |         self.block_store.put(&block).await?;
   |                                           ^ the trait `From<vec_store::block_store::StoreError>` is not implemented for `vec_errors::errors::ChainError`
error[E0277]: `?` couldn't convert the error to `vec_errors::errors::ChainError`
   --> vec_chain\src\chain.rs:100:43
    |
100 |         self.block_store.put(&block).await?;
    |                                           ^ the trait `From<vec_store::block_store::StoreError>` is not implemented for `vec_errors::errors::ChainError`
error[E0277]: the trait bound `vec_errors::errors::ChainError: From<vec_store::block_store::StoreError>` is not satisfied
   --> vec_chain\src\chain.rs:109:33
    |
109 |             Err(err) => Err(err.into()),
    |                                 ^^^^ the trait `From<vec_store::block_store::StoreError>` is not implemented for `vec_errors::errors::ChainError`
error[E0277]: `?` couldn't convert the error to `vec_errors::errors::ChainError`
   --> vec_chain\src\chain.rs:121:45
    |
121 |         let hash = hash_header(header).await?;
    |                                             ^ the trait `From<vec_block::block::BlockError>` is not implemented for `vec_errors::errors::ChainError`
error[E0277]: `?` couldn't convert the error to `vec_errors::errors::ChainError`
   --> vec_chain\src\chain.rs:132:59
    |
132 |         let message = hash_header_by_block(incoming_block)?;
    |                                                           ^ the trait `From<vec_block::block::BlockError>` is not implemented for `vec_errors::errors::ChainError`
error[E0277]: `?` couldn't convert the error to `vec_errors::errors::ChainError`
   --> vec_chain\src\chain.rs:133:58
    |
133 |         public_key.verify(&message, &signature.signature)?;
    |                                                          ^ the trait `From<ed25519_dalek::ed25519::Error>` is not implemented for `vec_errors::errors::ChainError`
error[E0277]: `?` couldn't convert the error to `vec_errors::errors::ChainError`
   --> vec_chain\src\chain.rs:157:64
    |
157 |         let last_block_hash = hash_header_by_block(&last_block)?.to_vec();
    |                                                                ^ the trait `From<vec_block::block::BlockError>` is not implemented for `vec_errors::errors::ChainError`
My errors.rs:
use thiserror::Error;

#[derive(Error, Debug)]
pub enum BlockError {
    #[error("Block header is missing")]
    MissingHeader,
    #[error(transparent)]
    MerkleTreeError(#[from] MerkleTreeError),
}

#[derive(Error, Debug)]
pub enum ChainError {
    #[error("Invalid public key in block")]
    InvalidPublicKey,
    #[error("Invalid transaction signature")]
    InvalidTransactionSignature,
    #[error("Index too high")]
    IndexTooHigh,
    #[error("Failed to create genesis block: {0}")]
    GenesisBlockCreationFailed(#[from] Box<dyn std::error::Error>),
    #[error("Block with hash {0} not found")]
    BlockNotFound(String),
    #[error("Chain is empty")]
    ChainIsEmpty,
    #[error("Given height ({0}) too high - height ({1})")]
    HeightTooHigh(usize, usize),
    #[error("Invalid previous block hash: expected ({0}), got ({1})")]
    InvalidPreviousBlockHash(String, String),
    #[error("Block header is missing")]
    BlockHeaderMissing,
    #[error("Invalid public key in transaction input")]
    InvalidPublicKeyInTransactionInput,
    #[error("Missing block header")]
    MissingBlockHeader,
}

#[derive(Error, Debug)]
pub enum MerkleTreeError {
    #[error("Failed to compute hashes")]
    HashingError,
}

#[derive(Debug, Error)]
pub enum NodeServiceError {
    #[error("Failed to create chain: {0}")]
    ChainCreationError(String),
    #[error("Failed to setup server: {0}")]
    ServerSetupError(#[from] tonic::transport::Error),
    #[error("Failed to bootstrap node: {0}")]
    NodeBootstrapError(String),
    #[error("Address parsing error: {0}")]
    AddrParseError(#[from] std::net::AddrParseError),
    #[error("Failed to broadcast transaction: {0}")]
    BroadcastTransactionError(String),
    #[error("Failed to bootstrap: {0}")]
    BootstrapError(String),
    #[error("Failed to make node client: {0}")]
    MakeNodeClientError(#[from] tonic::transport::Error),
    #[error("Failed to perform handshake: {0}")]
    HandshakeError(#[from] tonic::Status),
    #[error("Error encountered in bootstrap_network: {0}")]
    BootstrapNetworkError(String),
    #[error("Failed to create transaction: {0}")]
    CreateTransactionError(String),
    #[error("Failed to parse URI: {0}")]
    UriParseError(#[from] http::uri::InvalidUri),
    #[error("Failed to send shutdown signal")]
    ShutdownError,
}